package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strings"

	"cve-processor/config"
	"cve-processor/internal/cve"
	"cve-processor/internal/db"
	httphandler "cve-processor/internal/http"
	"cve-processor/internal/kafka"
)

func main() {
	config, err := config.LoadConfig()
	if err != nil {
		log.Fatal("Error loading config:", err)
	}

	db := db.ConnectToPostgresDB(config)
	kafkaBrokers := strings.Split(config.KafkaBrokers, ",")
	kafkaConsumer := kafka.NewConsumer(kafkaBrokers, config.KafkaGroupID, config.KafkaTopic, config.KafkaUsername, config.KafkaPassword)
	defer kafkaConsumer.Close()

	healthCheck := httphandler.NewHealthCheck(kafkaBrokers, config.KafkaTopic, db)

	go func() {
		http.HandleFunc("/readiness", healthCheck.ReadinessHandler)
		http.HandleFunc("/liveness", healthCheck.LivenessHandler)
		log.Fatal(http.ListenAndServe(":"+config.Port, nil))
	}()

	ctx := context.Background()
	run := true

	for run {
		msg, err := kafkaConsumer.ReadMessage(ctx)
		if err == nil {
			messageID := fmt.Sprintf("Partition: %d, Offset: %d", msg.Partition, msg.Offset)
			err = cve.ProcessRecord(msg.Value, db, messageID)
			if err != nil {
				log.Printf("Error processing CVE record: %v", err)
			}
		} else {
			log.Printf("Consumer error: %v\n", err)
		}

	}
}
