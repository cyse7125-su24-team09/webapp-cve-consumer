package cve

import (
	"encoding/json"
	"errors"
	"fmt"

	"gorm.io/gorm"
)

func ProcessRecord(jsonData []byte, db *gorm.DB, messageId string) error {
	var record CVERecordData
	if err := json.Unmarshal(jsonData, &record); err != nil {
		return fmt.Errorf("failed to parse record: %w", err)
	}

	metadata := record.CVEMetadata
	// fmt.Printf("Processing CVE record: %+v\n", metadata)

	return db.Transaction(func(tx *gorm.DB) error {
		var existingCVERecord CVERecord
		result := tx.Where(&CVERecord{CVEID: metadata.CVEID}).First(&existingCVERecord)
		if result.Error != nil && !errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return fmt.Errorf("failed to check for an existing record: %w", result.Error)
		}

		if result.RowsAffected != 0 && existingCVERecord.DateUpdated == metadata.DateUpdated {
			fmt.Printf("Processing skipped for duplicate CVE record %s with DateUpdated %s. Kafka Message ID: %s", metadata.CVEID, metadata.DateUpdated, messageId)
			return nil
		}

		version := 1
		if result.RowsAffected != 0 {
			existingCVERecord.CurrentVersion = existingCVERecord.CurrentVersion + 1
			existingCVERecord.DateUpdated = metadata.DateUpdated
			if err := tx.Save(&existingCVERecord).Error; err != nil {
				return fmt.Errorf("failed to update an existing record: %w", err)
			}
			version = existingCVERecord.CurrentVersion
		} else {
			newCVERecord := CVERecord{
				CVEID:          metadata.CVEID,
				DateUpdated:    metadata.DateUpdated,
				CurrentVersion: version,
			}
			if err := tx.Create(&newCVERecord).Error; err != nil {
				return fmt.Errorf("failed to create a new record: %w", err)
			}
		}

		cveVersion := CVEVersion{
			CVEID:   metadata.CVEID,
			Version: version,
			CVEData: jsonData,
		}
		if err := tx.Create(&cveVersion).Error; err != nil {
			return fmt.Errorf("failed to create a new version: %w", err)
		}

		return nil
	})
}
