package http

import (
	"context"
	"net/http"

	"github.com/segmentio/kafka-go"
	"gorm.io/gorm"
)

type HealthCheck struct {
	KafkaBrokers []string
	KafkaTopic   string
	DB           *gorm.DB
}

func NewHealthCheck(kafkaBrokers []string, kafkaTopic string, db *gorm.DB) *HealthCheck {
	return &HealthCheck{
		KafkaBrokers: kafkaBrokers,
		KafkaTopic:   kafkaTopic,
		DB:           db,
	}
}

func (hc *HealthCheck) ReadinessHandler(w http.ResponseWriter, r *http.Request) {
	ctx := context.Background()

	// Kafka readiness check
	topicExists := false
	atLeastOneBrokerConnected := false
	var conn *kafka.Conn
	var err error

	for _, broker := range hc.KafkaBrokers {
		conn, err = kafka.DialContext(ctx, "tcp", broker)
		if err == nil {
			defer conn.Close()
			atLeastOneBrokerConnected = true
			partitions, err := conn.ReadPartitions()
			if err == nil {
				for _, p := range partitions {
					if p.Topic == hc.KafkaTopic {
						topicExists = true
						break
					}
				}

			}
			if topicExists {
				break
			}
		}
	}
	if !atLeastOneBrokerConnected {
		http.Error(w, "All Kafka brokers are down", http.StatusServiceUnavailable)
		return
	}
	if err != nil {
		http.Error(w, "Kafka connection failed", http.StatusServiceUnavailable)
		return
	}

	if !topicExists {
		http.Error(w, "Kafka topic does not exist", http.StatusServiceUnavailable)
		return
	}

	// Database readiness check
	psqlDB, err := hc.DB.DB()
	if err != nil {
		http.Error(w, "Database connection failed", http.StatusServiceUnavailable)
		return
	}

	if err := psqlDB.PingContext(ctx); err != nil {
		http.Error(w, "Database ping failed", http.StatusServiceUnavailable)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Ready"))
}

func (hc *HealthCheck) LivenessHandler(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Alive"))
}
